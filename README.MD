# Coin chase server

## Multiplayer capabilities
TCP로 상태를 갱신 및 전파하며, protocol buffer를 사용합니다.

유저의 상태는 단순히 메모리에 유지됩니다. 서버가 꺼지면 유저의 정보도 사라집니다.
이렇게 구현한 이유는 게임 로직이 간단하기도 하고, 프로젝트의 목적을 고려하여 설계했습니다.

프로젝트의 목적이란 다수의 유저로부터의 빠른 속도로 상태 수신 전파를 서버에서 동시성 문제 없이 처리하는 것입니다.

직접 구현한 워커풀을 사용합니다. 
워커는 생성, 활성화, 비활성화, 장애 극복, 연관 자원 회수, 헬스 체크 등의 조치가 취해져 있습니다.

## 게임 규칙

1. 로그인 한 유저들은 한 맵에 배치 됩니다(각 유저는 로그인시 사용한 아이디로 구분됩니다).
2. 유저들의 시야는 2(게임상 그리드)로 제한됩니다. 그래서 자신이 획득해야 하는 자원(동전)이 현재 맵에 어디 있는지 알 수 없습니다. 그리드의 총 크기는 20 x 20입니다.
3. 동전들은 최소 1개 최대 10개가 생성됩니다(대부분의 경우 10개 가까이 생성됩니다).
4. 동전은 0.5초마다 랜덤위치로 도망갑니다. 유저의 위치로는 도망가지 않습니다(스스로 잡아먹히지 않습니다).
5. 유저가 동전을 따라잡아 먹으면 동전이 사라지고 1점이 그 유저에게 쌓입니다.
6. 아이템은 랜덤박스입니다. 시야가 두 배가 되거나, 절반이 됩니다. 아이템은 항상 두 개가 생성됩니다.
7. 동전과 아이템은 모두 소진시 재생성 됩니다.
8. 유저의 점수는 좌상단 스코어보드에 표시됩니다(클라이언트에서).

## Optimizations
1. Actor Model로 맵 상태 업데이트, Fan Out으로 broadcast
2. Hot code에서는 메모리 재할당 최소화(메세지 수신시 buffer 재사용)
3. tcp connection 게임 종료시 까지 재사용
    - 연속으로 보내지는 데이터들에서 처리 단위를 구분하는 로직 구현
4. protobuf 사용
5. 송신, 수신용 connection을 각각 사용
    - TCP connection은 분명 양방향이지만, 운영체제나 언어의 기본사양에 따라 send와 recv가 같은 소켓에서 동시에 일어나지 않을 수 있다는 사례를 발견해 따로 사용
6. 복사 최소화
7. empty struct signal

## 안정성을 위한 조치들
1. health check & revive
2. fault tolerance limit
3. worker creation check
4. maintain worker pool size
5. mutual termination of related goroutines
6. no race condition(go test -race 다회 실행 검증)

## 구조적 결함
mutex를 최소화하며 atomicity가 만족되도록 구조를 설계해야했으나, 미숙함으로 인해 여러 경합 상황 발생.  
이로 인해 mutex 및 rwmutex 다수 사용

goroutine이 코드전역에 다수 산개해있어 디버깅에 오랜 시간 소요 




